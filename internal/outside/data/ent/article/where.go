// Code generated by entc, DO NOT EDIT.

package article

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"gitlab.com/mcsolutions/find-psy/back/article-v1/internal/outside/data/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Email applies equality check predicate on the "email" field. It's identical to EmailEQ.
func Email(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// UserName applies equality check predicate on the "user_name" field. It's identical to UserNameEQ.
func UserName(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// Title applies equality check predicate on the "title" field. It's identical to TitleEQ.
func Title(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTitle), v))
	})
}

// Latinized applies equality check predicate on the "latinized" field. It's identical to LatinizedEQ.
func Latinized(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLatinized), v))
	})
}

// HTML applies equality check predicate on the "html" field. It's identical to HTMLEQ.
func HTML(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHTML), v))
	})
}

// ShortText applies equality check predicate on the "short_text" field. It's identical to ShortTextEQ.
func ShortText(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortText), v))
	})
}

// Lang applies equality check predicate on the "lang" field. It's identical to LangEQ.
func Lang(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLang), v))
	})
}

// Tags applies equality check predicate on the "tags" field. It's identical to TagsEQ.
func Tags(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTags), v))
	})
}

// B17Account applies equality check predicate on the "b17_account" field. It's identical to B17AccountEQ.
func B17Account(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldB17Account), v))
	})
}

// Source applies equality check predicate on the "source" field. It's identical to SourceEQ.
func Source(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSource), v))
	})
}

// IsPublished applies equality check predicate on the "is_published" field. It's identical to IsPublishedEQ.
func IsPublished(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsPublished), v))
	})
}

// Cdate applies equality check predicate on the "cdate" field. It's identical to CdateEQ.
func Cdate(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCdate), v))
	})
}

// Udate applies equality check predicate on the "udate" field. It's identical to UdateEQ.
func Udate(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUdate), v))
	})
}

// PubDate applies equality check predicate on the "pub_date" field. It's identical to PubDateEQ.
func PubDate(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPubDate), v))
	})
}

// IsProcessed applies equality check predicate on the "is_processed" field. It's identical to IsProcessedEQ.
func IsProcessed(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsProcessed), v))
	})
}

// EmailEQ applies the EQ predicate on the "email" field.
func EmailEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEmail), v))
	})
}

// EmailNEQ applies the NEQ predicate on the "email" field.
func EmailNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEmail), v))
	})
}

// EmailIn applies the In predicate on the "email" field.
func EmailIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEmail), v...))
	})
}

// EmailNotIn applies the NotIn predicate on the "email" field.
func EmailNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEmail), v...))
	})
}

// EmailGT applies the GT predicate on the "email" field.
func EmailGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEmail), v))
	})
}

// EmailGTE applies the GTE predicate on the "email" field.
func EmailGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEmail), v))
	})
}

// EmailLT applies the LT predicate on the "email" field.
func EmailLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEmail), v))
	})
}

// EmailLTE applies the LTE predicate on the "email" field.
func EmailLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEmail), v))
	})
}

// EmailContains applies the Contains predicate on the "email" field.
func EmailContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEmail), v))
	})
}

// EmailHasPrefix applies the HasPrefix predicate on the "email" field.
func EmailHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEmail), v))
	})
}

// EmailHasSuffix applies the HasSuffix predicate on the "email" field.
func EmailHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEmail), v))
	})
}

// EmailEqualFold applies the EqualFold predicate on the "email" field.
func EmailEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEmail), v))
	})
}

// EmailContainsFold applies the ContainsFold predicate on the "email" field.
func EmailContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEmail), v))
	})
}

// UserNameEQ applies the EQ predicate on the "user_name" field.
func UserNameEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserName), v))
	})
}

// UserNameNEQ applies the NEQ predicate on the "user_name" field.
func UserNameNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserName), v))
	})
}

// UserNameIn applies the In predicate on the "user_name" field.
func UserNameIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserName), v...))
	})
}

// UserNameNotIn applies the NotIn predicate on the "user_name" field.
func UserNameNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserName), v...))
	})
}

// UserNameGT applies the GT predicate on the "user_name" field.
func UserNameGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserName), v))
	})
}

// UserNameGTE applies the GTE predicate on the "user_name" field.
func UserNameGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserName), v))
	})
}

// UserNameLT applies the LT predicate on the "user_name" field.
func UserNameLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserName), v))
	})
}

// UserNameLTE applies the LTE predicate on the "user_name" field.
func UserNameLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserName), v))
	})
}

// UserNameContains applies the Contains predicate on the "user_name" field.
func UserNameContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserName), v))
	})
}

// UserNameHasPrefix applies the HasPrefix predicate on the "user_name" field.
func UserNameHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserName), v))
	})
}

// UserNameHasSuffix applies the HasSuffix predicate on the "user_name" field.
func UserNameHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserName), v))
	})
}

// UserNameEqualFold applies the EqualFold predicate on the "user_name" field.
func UserNameEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserName), v))
	})
}

// UserNameContainsFold applies the ContainsFold predicate on the "user_name" field.
func UserNameContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserName), v))
	})
}

// TitleEQ applies the EQ predicate on the "title" field.
func TitleEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTitle), v))
	})
}

// TitleNEQ applies the NEQ predicate on the "title" field.
func TitleNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTitle), v))
	})
}

// TitleIn applies the In predicate on the "title" field.
func TitleIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTitle), v...))
	})
}

// TitleNotIn applies the NotIn predicate on the "title" field.
func TitleNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTitle), v...))
	})
}

// TitleGT applies the GT predicate on the "title" field.
func TitleGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTitle), v))
	})
}

// TitleGTE applies the GTE predicate on the "title" field.
func TitleGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTitle), v))
	})
}

// TitleLT applies the LT predicate on the "title" field.
func TitleLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTitle), v))
	})
}

// TitleLTE applies the LTE predicate on the "title" field.
func TitleLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTitle), v))
	})
}

// TitleContains applies the Contains predicate on the "title" field.
func TitleContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTitle), v))
	})
}

// TitleHasPrefix applies the HasPrefix predicate on the "title" field.
func TitleHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTitle), v))
	})
}

// TitleHasSuffix applies the HasSuffix predicate on the "title" field.
func TitleHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTitle), v))
	})
}

// TitleEqualFold applies the EqualFold predicate on the "title" field.
func TitleEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTitle), v))
	})
}

// TitleContainsFold applies the ContainsFold predicate on the "title" field.
func TitleContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTitle), v))
	})
}

// LatinizedEQ applies the EQ predicate on the "latinized" field.
func LatinizedEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLatinized), v))
	})
}

// LatinizedNEQ applies the NEQ predicate on the "latinized" field.
func LatinizedNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLatinized), v))
	})
}

// LatinizedIn applies the In predicate on the "latinized" field.
func LatinizedIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLatinized), v...))
	})
}

// LatinizedNotIn applies the NotIn predicate on the "latinized" field.
func LatinizedNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLatinized), v...))
	})
}

// LatinizedGT applies the GT predicate on the "latinized" field.
func LatinizedGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLatinized), v))
	})
}

// LatinizedGTE applies the GTE predicate on the "latinized" field.
func LatinizedGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLatinized), v))
	})
}

// LatinizedLT applies the LT predicate on the "latinized" field.
func LatinizedLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLatinized), v))
	})
}

// LatinizedLTE applies the LTE predicate on the "latinized" field.
func LatinizedLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLatinized), v))
	})
}

// LatinizedContains applies the Contains predicate on the "latinized" field.
func LatinizedContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLatinized), v))
	})
}

// LatinizedHasPrefix applies the HasPrefix predicate on the "latinized" field.
func LatinizedHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLatinized), v))
	})
}

// LatinizedHasSuffix applies the HasSuffix predicate on the "latinized" field.
func LatinizedHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLatinized), v))
	})
}

// LatinizedEqualFold applies the EqualFold predicate on the "latinized" field.
func LatinizedEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLatinized), v))
	})
}

// LatinizedContainsFold applies the ContainsFold predicate on the "latinized" field.
func LatinizedContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLatinized), v))
	})
}

// HTMLEQ applies the EQ predicate on the "html" field.
func HTMLEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHTML), v))
	})
}

// HTMLNEQ applies the NEQ predicate on the "html" field.
func HTMLNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHTML), v))
	})
}

// HTMLIn applies the In predicate on the "html" field.
func HTMLIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHTML), v...))
	})
}

// HTMLNotIn applies the NotIn predicate on the "html" field.
func HTMLNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHTML), v...))
	})
}

// HTMLGT applies the GT predicate on the "html" field.
func HTMLGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHTML), v))
	})
}

// HTMLGTE applies the GTE predicate on the "html" field.
func HTMLGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHTML), v))
	})
}

// HTMLLT applies the LT predicate on the "html" field.
func HTMLLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHTML), v))
	})
}

// HTMLLTE applies the LTE predicate on the "html" field.
func HTMLLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHTML), v))
	})
}

// HTMLContains applies the Contains predicate on the "html" field.
func HTMLContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldHTML), v))
	})
}

// HTMLHasPrefix applies the HasPrefix predicate on the "html" field.
func HTMLHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldHTML), v))
	})
}

// HTMLHasSuffix applies the HasSuffix predicate on the "html" field.
func HTMLHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldHTML), v))
	})
}

// HTMLEqualFold applies the EqualFold predicate on the "html" field.
func HTMLEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldHTML), v))
	})
}

// HTMLContainsFold applies the ContainsFold predicate on the "html" field.
func HTMLContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldHTML), v))
	})
}

// ShortTextEQ applies the EQ predicate on the "short_text" field.
func ShortTextEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldShortText), v))
	})
}

// ShortTextNEQ applies the NEQ predicate on the "short_text" field.
func ShortTextNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldShortText), v))
	})
}

// ShortTextIn applies the In predicate on the "short_text" field.
func ShortTextIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldShortText), v...))
	})
}

// ShortTextNotIn applies the NotIn predicate on the "short_text" field.
func ShortTextNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldShortText), v...))
	})
}

// ShortTextGT applies the GT predicate on the "short_text" field.
func ShortTextGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldShortText), v))
	})
}

// ShortTextGTE applies the GTE predicate on the "short_text" field.
func ShortTextGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldShortText), v))
	})
}

// ShortTextLT applies the LT predicate on the "short_text" field.
func ShortTextLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldShortText), v))
	})
}

// ShortTextLTE applies the LTE predicate on the "short_text" field.
func ShortTextLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldShortText), v))
	})
}

// ShortTextContains applies the Contains predicate on the "short_text" field.
func ShortTextContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldShortText), v))
	})
}

// ShortTextHasPrefix applies the HasPrefix predicate on the "short_text" field.
func ShortTextHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldShortText), v))
	})
}

// ShortTextHasSuffix applies the HasSuffix predicate on the "short_text" field.
func ShortTextHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldShortText), v))
	})
}

// ShortTextEqualFold applies the EqualFold predicate on the "short_text" field.
func ShortTextEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldShortText), v))
	})
}

// ShortTextContainsFold applies the ContainsFold predicate on the "short_text" field.
func ShortTextContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldShortText), v))
	})
}

// LangEQ applies the EQ predicate on the "lang" field.
func LangEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLang), v))
	})
}

// LangNEQ applies the NEQ predicate on the "lang" field.
func LangNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLang), v))
	})
}

// LangIn applies the In predicate on the "lang" field.
func LangIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLang), v...))
	})
}

// LangNotIn applies the NotIn predicate on the "lang" field.
func LangNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLang), v...))
	})
}

// LangGT applies the GT predicate on the "lang" field.
func LangGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLang), v))
	})
}

// LangGTE applies the GTE predicate on the "lang" field.
func LangGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLang), v))
	})
}

// LangLT applies the LT predicate on the "lang" field.
func LangLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLang), v))
	})
}

// LangLTE applies the LTE predicate on the "lang" field.
func LangLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLang), v))
	})
}

// LangContains applies the Contains predicate on the "lang" field.
func LangContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLang), v))
	})
}

// LangHasPrefix applies the HasPrefix predicate on the "lang" field.
func LangHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLang), v))
	})
}

// LangHasSuffix applies the HasSuffix predicate on the "lang" field.
func LangHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLang), v))
	})
}

// LangEqualFold applies the EqualFold predicate on the "lang" field.
func LangEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLang), v))
	})
}

// LangContainsFold applies the ContainsFold predicate on the "lang" field.
func LangContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLang), v))
	})
}

// TagsEQ applies the EQ predicate on the "tags" field.
func TagsEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTags), v))
	})
}

// TagsNEQ applies the NEQ predicate on the "tags" field.
func TagsNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTags), v))
	})
}

// TagsIn applies the In predicate on the "tags" field.
func TagsIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTags), v...))
	})
}

// TagsNotIn applies the NotIn predicate on the "tags" field.
func TagsNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTags), v...))
	})
}

// TagsGT applies the GT predicate on the "tags" field.
func TagsGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTags), v))
	})
}

// TagsGTE applies the GTE predicate on the "tags" field.
func TagsGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTags), v))
	})
}

// TagsLT applies the LT predicate on the "tags" field.
func TagsLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTags), v))
	})
}

// TagsLTE applies the LTE predicate on the "tags" field.
func TagsLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTags), v))
	})
}

// TagsContains applies the Contains predicate on the "tags" field.
func TagsContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTags), v))
	})
}

// TagsHasPrefix applies the HasPrefix predicate on the "tags" field.
func TagsHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTags), v))
	})
}

// TagsHasSuffix applies the HasSuffix predicate on the "tags" field.
func TagsHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTags), v))
	})
}

// TagsIsNil applies the IsNil predicate on the "tags" field.
func TagsIsNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTags)))
	})
}

// TagsNotNil applies the NotNil predicate on the "tags" field.
func TagsNotNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTags)))
	})
}

// TagsEqualFold applies the EqualFold predicate on the "tags" field.
func TagsEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTags), v))
	})
}

// TagsContainsFold applies the ContainsFold predicate on the "tags" field.
func TagsContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTags), v))
	})
}

// B17AccountEQ applies the EQ predicate on the "b17_account" field.
func B17AccountEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldB17Account), v))
	})
}

// B17AccountNEQ applies the NEQ predicate on the "b17_account" field.
func B17AccountNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldB17Account), v))
	})
}

// B17AccountIn applies the In predicate on the "b17_account" field.
func B17AccountIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldB17Account), v...))
	})
}

// B17AccountNotIn applies the NotIn predicate on the "b17_account" field.
func B17AccountNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldB17Account), v...))
	})
}

// B17AccountGT applies the GT predicate on the "b17_account" field.
func B17AccountGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldB17Account), v))
	})
}

// B17AccountGTE applies the GTE predicate on the "b17_account" field.
func B17AccountGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldB17Account), v))
	})
}

// B17AccountLT applies the LT predicate on the "b17_account" field.
func B17AccountLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldB17Account), v))
	})
}

// B17AccountLTE applies the LTE predicate on the "b17_account" field.
func B17AccountLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldB17Account), v))
	})
}

// B17AccountContains applies the Contains predicate on the "b17_account" field.
func B17AccountContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldB17Account), v))
	})
}

// B17AccountHasPrefix applies the HasPrefix predicate on the "b17_account" field.
func B17AccountHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldB17Account), v))
	})
}

// B17AccountHasSuffix applies the HasSuffix predicate on the "b17_account" field.
func B17AccountHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldB17Account), v))
	})
}

// B17AccountIsNil applies the IsNil predicate on the "b17_account" field.
func B17AccountIsNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldB17Account)))
	})
}

// B17AccountNotNil applies the NotNil predicate on the "b17_account" field.
func B17AccountNotNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldB17Account)))
	})
}

// B17AccountEqualFold applies the EqualFold predicate on the "b17_account" field.
func B17AccountEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldB17Account), v))
	})
}

// B17AccountContainsFold applies the ContainsFold predicate on the "b17_account" field.
func B17AccountContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldB17Account), v))
	})
}

// SourceEQ applies the EQ predicate on the "source" field.
func SourceEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSource), v))
	})
}

// SourceNEQ applies the NEQ predicate on the "source" field.
func SourceNEQ(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSource), v))
	})
}

// SourceIn applies the In predicate on the "source" field.
func SourceIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSource), v...))
	})
}

// SourceNotIn applies the NotIn predicate on the "source" field.
func SourceNotIn(vs ...string) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSource), v...))
	})
}

// SourceGT applies the GT predicate on the "source" field.
func SourceGT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSource), v))
	})
}

// SourceGTE applies the GTE predicate on the "source" field.
func SourceGTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSource), v))
	})
}

// SourceLT applies the LT predicate on the "source" field.
func SourceLT(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSource), v))
	})
}

// SourceLTE applies the LTE predicate on the "source" field.
func SourceLTE(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSource), v))
	})
}

// SourceContains applies the Contains predicate on the "source" field.
func SourceContains(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSource), v))
	})
}

// SourceHasPrefix applies the HasPrefix predicate on the "source" field.
func SourceHasPrefix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSource), v))
	})
}

// SourceHasSuffix applies the HasSuffix predicate on the "source" field.
func SourceHasSuffix(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSource), v))
	})
}

// SourceIsNil applies the IsNil predicate on the "source" field.
func SourceIsNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSource)))
	})
}

// SourceNotNil applies the NotNil predicate on the "source" field.
func SourceNotNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSource)))
	})
}

// SourceEqualFold applies the EqualFold predicate on the "source" field.
func SourceEqualFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSource), v))
	})
}

// SourceContainsFold applies the ContainsFold predicate on the "source" field.
func SourceContainsFold(v string) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSource), v))
	})
}

// IsPublishedEQ applies the EQ predicate on the "is_published" field.
func IsPublishedEQ(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsPublished), v))
	})
}

// IsPublishedNEQ applies the NEQ predicate on the "is_published" field.
func IsPublishedNEQ(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIsPublished), v))
	})
}

// CdateEQ applies the EQ predicate on the "cdate" field.
func CdateEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCdate), v))
	})
}

// CdateNEQ applies the NEQ predicate on the "cdate" field.
func CdateNEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCdate), v))
	})
}

// CdateIn applies the In predicate on the "cdate" field.
func CdateIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCdate), v...))
	})
}

// CdateNotIn applies the NotIn predicate on the "cdate" field.
func CdateNotIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCdate), v...))
	})
}

// CdateGT applies the GT predicate on the "cdate" field.
func CdateGT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCdate), v))
	})
}

// CdateGTE applies the GTE predicate on the "cdate" field.
func CdateGTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCdate), v))
	})
}

// CdateLT applies the LT predicate on the "cdate" field.
func CdateLT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCdate), v))
	})
}

// CdateLTE applies the LTE predicate on the "cdate" field.
func CdateLTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCdate), v))
	})
}

// UdateEQ applies the EQ predicate on the "udate" field.
func UdateEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUdate), v))
	})
}

// UdateNEQ applies the NEQ predicate on the "udate" field.
func UdateNEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUdate), v))
	})
}

// UdateIn applies the In predicate on the "udate" field.
func UdateIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUdate), v...))
	})
}

// UdateNotIn applies the NotIn predicate on the "udate" field.
func UdateNotIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUdate), v...))
	})
}

// UdateGT applies the GT predicate on the "udate" field.
func UdateGT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUdate), v))
	})
}

// UdateGTE applies the GTE predicate on the "udate" field.
func UdateGTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUdate), v))
	})
}

// UdateLT applies the LT predicate on the "udate" field.
func UdateLT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUdate), v))
	})
}

// UdateLTE applies the LTE predicate on the "udate" field.
func UdateLTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUdate), v))
	})
}

// UdateIsNil applies the IsNil predicate on the "udate" field.
func UdateIsNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUdate)))
	})
}

// UdateNotNil applies the NotNil predicate on the "udate" field.
func UdateNotNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUdate)))
	})
}

// PubDateEQ applies the EQ predicate on the "pub_date" field.
func PubDateEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPubDate), v))
	})
}

// PubDateNEQ applies the NEQ predicate on the "pub_date" field.
func PubDateNEQ(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPubDate), v))
	})
}

// PubDateIn applies the In predicate on the "pub_date" field.
func PubDateIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPubDate), v...))
	})
}

// PubDateNotIn applies the NotIn predicate on the "pub_date" field.
func PubDateNotIn(vs ...time.Time) predicate.Article {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Article(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPubDate), v...))
	})
}

// PubDateGT applies the GT predicate on the "pub_date" field.
func PubDateGT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPubDate), v))
	})
}

// PubDateGTE applies the GTE predicate on the "pub_date" field.
func PubDateGTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPubDate), v))
	})
}

// PubDateLT applies the LT predicate on the "pub_date" field.
func PubDateLT(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPubDate), v))
	})
}

// PubDateLTE applies the LTE predicate on the "pub_date" field.
func PubDateLTE(v time.Time) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPubDate), v))
	})
}

// PubDateIsNil applies the IsNil predicate on the "pub_date" field.
func PubDateIsNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPubDate)))
	})
}

// PubDateNotNil applies the NotNil predicate on the "pub_date" field.
func PubDateNotNil() predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPubDate)))
	})
}

// IsProcessedEQ applies the EQ predicate on the "is_processed" field.
func IsProcessedEQ(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsProcessed), v))
	})
}

// IsProcessedNEQ applies the NEQ predicate on the "is_processed" field.
func IsProcessedNEQ(v bool) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIsProcessed), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Article) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Article) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Article) predicate.Article {
	return predicate.Article(func(s *sql.Selector) {
		p(s.Not())
	})
}
